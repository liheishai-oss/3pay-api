# 分账进度实施

## 1. 代码现状概览

### 1.1 已实现能力
- **支付闭环入队**：支付回调、补单服务都会在订单成功后将任务写入 `royalty:queue`，并记录链路日志，保证分账与核心交易解耦。
```358:395:app/api/controller/v1/PaymentNotifyController.php
                $queueKey = \app\common\constants\CacheKeys::getRoyaltyQueueKey();
                $queueData = json_encode([
                    'order_id' => $order->id,
                    'operator_ip' => $payIp,
                    'operator_agent' => $userAgent ?: 'PaymentNotify',
                    'timestamp' => time()
                ]);
                \support\Redis::lpush($queueKey, $queueData);
```
- **自动消费与兜底扫描**：`OrderAutoRoyalty` 每秒消费队列、每10分钟扫描数据库，已具备秒级响应+漏单兜底机制。
```65:143:app/process/OrderAutoRoyalty.php
                if (Redis::get($processingKey)) {
                    Redis::lpush($queueKey, $orderIdJson);
                    continue;
                }
                Redis::setex($processingKey, 300, '1');
                ...
                $result = RoyaltyService::processRoyalty($order, $operatorIp, $operatorAgent);
```
- **核心分账流程**：`RoyaltyService::processRoyalty` 完成条件校验、记录创建、调用支付宝分账、落库日志、异常告警，配合 `RoyaltyConstants` 自动禁用高风险主体。
```151:305:app/service/royalty/RoyaltyService.php
            if ($alipayResult['success']) {
                $royaltyRecord->royalty_status = OrderRoyalty::ROYALTY_STATUS_SUCCESS;
                ...
            } else {
                $royaltyRecord->royalty_status = OrderRoyalty::ROYALTY_STATUS_FAILED;
                $royaltyRecord->royalty_error = $alipayResult['message'] ?? '分账失败';
                ...
                if (RoyaltyConstants::shouldDisableSubject($subCode, $errorMessage)) {
                    $subject->status = Subject::STATUS_DISABLED;
                    $subject->save();
                }
            }
```
- **失败首告推送**：同一订单首次分账失败会写入 Redis 标记，并通过 `TelegramMessageQueue` 推送失败原因，确保运营获知且避免重复骚扰。
- **待支付自动补偿**：当订单刚入队但支付状态尚未落库时，会被送入 `royalty:pending:*` 延迟队列，CRON 每 15 秒将到期任务重新压回 `royalty:queue`，彻底解决“支付成功但未分账”的时间差问题。
- **后台观测与手动兜底**：管理端提供列表、详情、单/批量重试接口，支持人工介入、查看 `alipay_result` 解析内容。

### 1.2 缺口与风险
- **商家分账账户仍为空**：商家分账部分仍保留占位写法，`payee_user_id` 永远为空，导致该模式无法上线。
```489:529:app/service/royalty/RoyaltyService.php
                $payeeAccount = ''; // 从商户配置获取
                $payeeUserId = ''; // 从商户配置获取
                if (empty($payeeUserId)) {
                    throw new Exception("商户分账需要配置收款人支付宝用户ID");
                }
```
- **并发锁仍为普通 `setex`**：当前只判断 `Redis::get` 再 `setex`，缺少 `SET NX EX` 原子性，无法杜绝多进程竞态。
```86:143:app/process/OrderAutoRoyalty.php
                if (Redis::get($processingKey)) {
                    Redis::lpush($queueKey, $orderIdJson);
                    continue;
                }
                Redis::setex($processingKey, 300, '1');
```
- **没有自动重试通道**：系统内不存在 `royalty:retry:*` 队列或延迟任务，失败记录只能依赖人工重试或再次入队。
- **金额仍用浮点计算**：`calculateRoyaltyAmount` 直接 `round`，存在累计误差风险，尚未改造为“分”为单位的整数计算。
```454:477:app/service/royalty/RoyaltyService.php
                $royaltyAmount = round($orderAmount * ($royaltyRate / 100), 2);
                $subjectAmount = round($orderAmount - $royaltyAmount, 2);
                $total = round($royaltyAmount + $subjectAmount, 2);
```
- **支付宝接口未显式设置超时**：`AlipayRoyaltyService::royalty` 直接调用 EasySDK，没有单次调用的连接/响应超时策略，网络抖动会阻塞进程。
- **兜底扫描使用 `whereDoesntHave`**：当前仍旧关联排除查询，随着订单量增长会变慢，也未新增建议的复合索引。
```185:233:app/process/OrderAutoRoyalty.php
            $orders = Order::with(['subject', 'product'])
                ->where('pay_status', Order::PAY_STATUS_PAID)
                ->where('pay_time', '<=', $cutoffTime)
                ->whereDoesntHave('royaltyRecords', function ($query) {
                    $query->where('royalty_status', OrderRoyalty::ROYALTY_STATUS_SUCCESS);
                })
                ->limit(self::BATCH_SIZE)
                ->get();
```
- **分账结果查询未落地**：查询接口仍是 TODO，缺少 `alipay.trade.order.settle.query` 实现及定时任务。
```185:204:app/service/alipay/AlipayRoyaltyService.php
            // TODO: 实现查询分账结果的接口
            return [
                'success' => false,
                'message' => '查询分账结果接口待实现',
                'data' => []
            ];
```
- **账号校验与日志仍需补强**：单笔分账虽校验 `payee_user_id`，但未覆盖 `payee_account/payee_name` 为空的情况，日志也未采用结构化通道输出。

## 2. 问题跟踪矩阵
| 编号 | 目标 | 当前实现 | 状态 | 下一步 |
| --- | --- | --- | --- | --- |
| 1 | 商家分账账号统一 | 仍为空占位 | ❌ 未开始 | 扩展 `single_royalty` 或商户配置，落地读取逻辑及后台校验 |
| 2 | 并发锁改造 | `get`+`setex` | ⚠️ 部分 | 换成 `SET key value NX EX 60`，失败重入队，增加 finally 解锁兜底 |
| 3 | 失败自动重试 | 仅人工重试 | ❌ 未开始 | 设计 `royalty:retry:{delay}`、错误分级、最大重试次数 & 指标 |
| 4 | 金额精度 | round 浮点 | ❌ 未开始 | 统一以“分”为单位计算，封装校验函数并补单元测试 |
| 5 | 支付宝超时 | EasySDK 默认 | ❌ 未开始 | `Factory::setOptions` 前注入 `httpClient` 超时或 Guzzle 配置，分类错误为可重试 |
| 6 | 兜底性能 | `whereDoesntHave` | ⚠️ 待优化 | 改造为 LEFT JOIN + `order_royalty` 复合索引，按主键分页，低峰调度 |
| 7 | 结果查询 | TODO | ❌ 未开始 | 封装 `alipay.trade.order.settle.query`，新增定时任务同步“分账中”记录 |
| 8 | 账号验证 | 仅检查 `payee_user_id` | ⚠️ 部分 | 增加 `payee_account/name` 判空 & 状态校验，后台配置强校验 |
| 9 | 错误码提取 | `RoyaltyConstants::extractErrorCode` | ✅ 已完成 | 保持、补充测试及文档 |
|10 | 日志规范 | 基本日志+channel | ⚠️ 部分 | 统一结构化字段、拆分 `royalty` channel、补链路ID/耗时 |

## 3. 实施计划（建议）
1. **阶段一（本周）**
   - 解决编号 1、2：完成商家账号读取链路与 Redis 分布式锁升级，消除基础阻断风险。
   - 输出锁、账号改造测试用例，更新后台校验。
2. **阶段二（下周 - T+1）**
   - 编号 3、4、5：搭建重试队列、金额整数化、支付宝请求超时及错误分级，保证自动恢复力。
   - 联动监控告警，跟踪失败率与重试次数。
3. **阶段三（T+2）**
   - 编号 6、7：优化兜底查询、实现结果查询任务，保障一致性与性能。
4. **阶段四（T+3）**
   - 编号 8、10：完善账号校验、日志结构化，补测试、文档收尾。

## 阶段二详细方案（重试 / 金额精度 / 超时）

### 3.1 失败自动重试
- **队列设计**：采用 Redis List `royalty:retry:queue`，元素保存 `order_id`、`royalty_id`、`retry_count`、`next_at`。
- **入队规则**：`RoyaltyService::processRoyalty` 在收到支付宝失败时，根据错误分类（网络超时、系统繁忙等临时错误）写入重试队列；永久性错误（账号信息错误、权限问题）直接保持失败。
- **调度进程**：`OrderAutoRoyalty` 新增 `processRetryQueue()`，每 30 秒扫描重试队列头元素，如 `next_at <= now()` 则重新调用 `RoyaltyService::processRoyalty`，否则重新压回队尾。
- **限制策略**：最大重试次数 3 次；超过次数时标记 `royalty_error` 并告警。每次重试间隔 5 分钟（可根据错误类型动态调整）。
- **监控指标**：记录 `retry_count`、成功率、失败错误码，输出到 `royalty` 日志通道，便于 Prometheus/ELK 采集。

### 3.2 金额计算使用“分”为单位
- **统一入口**：`RoyaltyService::calculateRoyaltyAmount` 先通过 `MoneyHelper::convertToCents()` 将订单金额转为分，再按比例整型计算，最后用 `MoneyHelper::convertToYuan()` 输出两位小数。
- **一致性校验**：分账金额（分） + 主体金额（分）必须严格等于订单金额（分），否则抛出异常并记录链路日志。
- **数据库写入**：仍存储为 decimal(10,2)，但内部逻辑全程使用分，彻底消除浮点误差。

### 3.3 支付宝调用超时与错误分类
- **易 SDK 配置**：`AlipayConfig::getConfig` 注入 `http` 选项（连接 5s / 总 10s，毫秒级别），避免长时间阻塞。
- **错误分类**：`AlipayRoyaltyService::royalty` 不再直接抛异常，统一返回包含 `sub_code`、`retryable` 的结构；网络/超时异常自动标记为可重试。
- **日志与指标**：所有失败场景记录 `retryable` 标记，`RoyaltyService` 根据 `sub_code`/关键字做最终判定并写入重试队列。

> 阶段二的代码改动将围绕以上三块展开，先实现重试队列与金额精度，再补充支付宝调用策略，确保分账链路具备自愈与稳定能力。

## 4. 需要确认/支持
- 商家分账收款信息来源：是否沿用 `single_royalty`、还是新表？需产品/业务确认。
- 自动重试队列运行环境：是否允许使用 Redis 延迟队列 / 定时任务进程？
- 支付宝接口权限：`alipay.trade.order.settle.query` 是否已申请；如无需安排申请窗口。

> 本文档将作为新的分账交付基线，后续每次迭代更新本文件，确保研发、测试、运维同步进度。
