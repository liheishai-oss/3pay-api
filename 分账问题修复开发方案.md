# 分账问题修复开发方案

## 数据库表说明

### `single_royalty` 表 - 收款账号配置表

**表结构**：
- `id`: 主键ID
- `agent_id`: 代理商ID
- `payee_name`: 收款人姓名
- `payee_account`: 收款人账号
- `payee_user_id`: 收款人用户ID（支付宝用户ID）
- `status`: 状态（1启用 0禁用）
- `created_at`: 创建时间
- `updated_at`: 更新时间

**使用规则**：
- **`single_royalty` 是统一的收款账号配置表，所有代理商的分账都从该表读取收款账号信息**
- **只读取开启状态（`status = 1`）下的收款账号记录**
- 单笔分账（`ROYALTY_TYPE_SINGLE`）：根据 `agent_id` 和 `status = 1` 查询收款账号
- 商家分账（`ROYALTY_TYPE_MERCHANT`）：同样根据 `agent_id` 和 `status = 1` 查询收款账号
- 查询条件：`where('agent_id', $agent_id)->where('status', SingleRoyalty::STATUS_ENABLED)->first()`

---

### `order_royalty` 表 - 订单分账记录表

**表结构**：
- `id`: 主键ID
- `order_id`: 订单ID
- `platform_order_no`: 平台订单号
- `trade_no`: 支付宝交易号
- `royalty_type`: 分账方式（none/single/merchant）
- `royalty_mode`: 分账模式（normal/master_sub）
- `royalty_rate`: 分账比例（百分比）
- `subject_id`: 主体ID
- `subject_amount`: 主体收款金额
- `payee_type`: 收款人类型（agent/merchant/single）
- `payee_id`: 收款人ID
- `payee_name`: 收款人名称
- `payee_account`: 收款人账号
- `payee_user_id`: 收款人支付宝用户ID
- `royalty_amount`: 分账金额
- `royalty_status`: 分账状态（0=待分账, 1=分账中, 2=分账成功, 3=分账失败）
- `royalty_time`: 分账时间
- `royalty_error`: 分账失败原因
- `alipay_royalty_no`: 支付宝分账单号
- `alipay_result`: 支付宝分账返回结果（JSON格式）
- `created_at`: 创建时间
- `updated_at`: 更新时间

**使用规则**：
- **`order_royalty` 是订单分账记录表，记录每个订单的分账处理过程和结果**
- 每个订单对应一条分账记录（或根据业务需要支持多条记录）
- 分账状态流转：待分账(0) → 分账中(1) → 分账成功(2) 或 分账失败(3)
- 用于防止重复分账：查询是否存在成功分账记录 `where('order_id', $order_id)->where('royalty_status', OrderRoyalty::ROYALTY_STATUS_SUCCESS)->exists()`
- 用于兜底扫描：查询已支付但未分账的订单（通过关联查询或 LEFT JOIN）
- 保存支付宝分账结果，便于后续查询和对账

**主要索引**：
- `idx_order_id`: 订单ID索引（用于查询订单的分账记录）
- `idx_platform_order_no`: 平台订单号索引
- `idx_trade_no`: 支付宝交易号索引
- `idx_royalty_status`: 分账状态索引（用于查询特定状态的记录）
- `idx_subject_id`: 主体ID索引

---

## 第一阶段：高优先级问题修复

### 问题1：完善商家分账收款账号配置

**问题描述**：
- 当前商家分账（`ROYALTY_TYPE_MERCHANT`）类型的分账收款账号信息为空
- 代码中 `payeeAccount` 和 `payeeUserId` 为空字符串，导致分账失败

**实施方案**：
- **统一从 `single_royalty` 表读取收款账号信息**（与单笔分账一致）
- 修改商家分账计算逻辑，从 `single_royalty` 表查询收款账号
- 查询条件：`where('agent_id', $subject->agent_id)->where('status', SingleRoyalty::STATUS_ENABLED)`
- 如果查询不到开启状态下的收款账号记录，抛出明确的错误提示
- 在主体配置商家分账时，验证关联代理商是否在 `single_royalty` 表中配置了启用状态的收款账号

**涉及文件**：
- `app/service/royalty/RoyaltyService.php`（修改商家分账计算逻辑，从 `single_royalty` 表读取）
- `app/model/SingleRoyalty.php`（已存在，无需修改）

---

### 问题2：优化并发控制机制

**实施方案**：
- 将Redis标记改为使用Redis分布式锁（SET NX EX）
- 确保同一时间只有一个进程能处理同一订单
- 锁的过期时间设置为分账处理的最大预计时间（如60秒）
- 处理完成后主动释放锁
- 如果获取锁失败，将任务重新放回队列

**涉及文件**：
- `app/process/OrderAutoRoyalty.php`（修改并发控制逻辑）
- `app/service/royalty/RoyaltyService.php`（添加锁检查）

---

## 第二阶段：中优先级问题修复

### 问题3：添加分账失败自动重试机制

**实施方案**：
- 创建分账重试队列（`royalty:retry:queue`）
- 分账失败后，根据错误类型判断是否为临时性错误
- 临时性错误（如网络超时、接口超时）加入重试队列
- 永久性错误（如账号不存在、金额不足）不重试，记录日志
- 重试队列处理：延迟5分钟后重试，最多重试3次
- 超过重试次数后，标记为永久失败

**涉及文件**：
- `app/service/royalty/RoyaltyService.php`（添加错误分类和重试逻辑）
- `app/process/OrderAutoRoyalty.php`（添加重试队列处理）
- `app/common/constants/RoyaltyConstants.php`（定义错误类型常量）

---

### 问题4：优化分账金额计算精度

**实施方案**：
- 使用整数计算（以分为单位），避免浮点数精度问题
- 分账金额计算：订单金额（分）× 分账比例 / 100
- 主体金额 = 订单金额 - 分账金额（保证总额准确）
- 最后转换为元（除以100）并保留两位小数
- 添加金额验证，确保分账金额 + 主体金额 = 订单金额

**涉及文件**：
- `app/service/royalty/RoyaltyService.php`（修改金额计算逻辑）

---

### 问题5：添加支付宝接口超时控制

**实施方案**：
- 在调用支付宝接口时设置超时时间（连接超时5秒，总超时10秒）
- 超时后抛出超时异常，标记为临时性错误
- 将超时错误加入重试队列
- 记录超时日志，便于排查问题

**涉及文件**：
- `app/service/alipay/AlipayRoyaltyService.php`（添加超时配置）

---

### 问题6：优化兜底扫描查询性能

**实施方案**：
- 使用LEFT JOIN代替关联查询，提升查询效率
- 添加数据库索引：`order_royalty(order_id, royalty_status)`
- 使用分页查询，避免一次性查询大量数据
- 考虑在业务低峰期执行兜底扫描（如凌晨）

**涉及文件**：
- `app/process/OrderAutoRoyalty.php`（优化查询逻辑）
- 数据库迁移文件（添加索引）

---

### 问题7：实现分账结果查询接口

**实施方案**：
- 实现支付宝分账结果查询接口（`alipay.trade.order.settle.query`）
- 创建定时任务，每5分钟查询一次状态为"分账中"的记录
- 根据支付宝返回的实际状态更新本地记录
- 发现不一致时记录日志并发送通知

**涉及文件**：
- `app/service/alipay/AlipayRoyaltyService.php`（实现查询接口）
- 创建定时任务进程或使用Crontab

---

### 问题8：完善分账收款账号验证

**实施方案**：
- 在从 `single_royalty` 表获取收款账号信息后，验证所有必需字段（`payee_user_id`、`payee_name`、`payee_account`）
- 验证收款账号记录的状态是否为启用（`status = 1`）
- 如果字段缺失或状态为禁用，抛出明确的错误信息
- 在配置分账收款账号时验证，避免运行时才发现问题

**涉及文件**：
- `app/service/royalty/RoyaltyService.php`（添加验证逻辑，统一适用于单笔分账和商家分账）
- `app/admin/controller/v1/SingleRoyaltyController.php`（配置时验证）

---

## 第三阶段：低优先级优化

### 问题9：简化错误码提取逻辑

**实施方案**：
- 在 `RoyaltyConstants` 类中统一错误码提取方法
- 使用循环遍历可能的位置提取错误码
- 提取后的错误码统一格式和存储
- 便于后续扩展和维护

**涉及文件**：
- `app/common/constants/RoyaltyConstants.php`（优化错误码提取）
- `app/service/royalty/RoyaltyService.php`（简化错误处理逻辑）

---

### 问题10：完善日志记录

**实施方案**：
- 在每个关键步骤添加详细日志
- 记录关键数据（订单号、金额、状态、错误信息等）
- 使用结构化日志格式（JSON格式）
- 区分不同日志级别（INFO、WARN、ERROR）
- 使用独立的日志通道（royalty）

**涉及文件**：
- `app/service/royalty/RoyaltyService.php`（添加日志）
- `app/process/OrderAutoRoyalty.php`（完善日志）
- `app/service/alipay/AlipayRoyaltyService.php`（完善日志）

---

## 实施计划

### 阶段一（1-2周）
- 问题1：完善商家分账收款账号配置
- 问题2：优化并发控制机制

### 阶段二（2-3周）
- 问题3：添加分账失败自动重试机制
- 问题4：优化分账金额计算精度
- 问题5：添加支付宝接口超时控制
- 问题6：优化兜底扫描查询性能
- 问题7：实现分账结果查询接口
- 问题8：完善分账收款账号验证

### 阶段三（1周）
- 问题9：简化错误码提取逻辑
- 问题10：完善日志记录

---

## 测试要点

### 功能测试
- 单笔分账功能正常使用（从 `single_royalty` 表读取启用状态的收款账号）
- 商家分账功能正常使用（从 `single_royalty` 表读取启用状态的收款账号）
- 并发情况下不重复分账
- 分账失败后自动重试
- 金额计算准确无误
- 超时后正确重试
- 兜底扫描能发现遗漏订单
- 分账状态查询准确
- 收款账号配置验证有效（状态为启用、字段完整）

### 性能测试
- 分账处理速度
- 并发处理能力
- 数据库查询效率
- Redis队列处理效率

### 稳定性测试
- 长时间运行稳定性
- 异常情况处理
- 错误恢复能力

---

## 风险评估

### 高风险
- 商家分账收款账号读取逻辑改动（修改代码逻辑，从 `single_royalty` 表读取，不涉及数据库结构变更）
- 并发控制机制改动（影响现有逻辑）

### 中风险
- 金额计算逻辑改动（影响分账准确性）
- 重试机制添加（可能增加系统负载）

### 低风险
- 日志完善（不影响核心逻辑）
- 错误码提取优化（代码重构）

---

## 注意事项

1. **收款账号表统一**：所有代理商的分账（单笔分账和商家分账）都统一从 `single_royalty` 表读取启用状态（`status = 1`）下的收款账号信息
2. **无需数据库变更**：商家分账收款账号配置改进只需修改代码逻辑，无需修改数据库结构
3. **向后兼容**：确保新代码兼容现有数据，已存在的 `single_royalty` 表数据可直接使用
4. **灰度发布**：建议先在小范围测试，再全量发布
5. **监控告警**：添加关键指标监控和告警，特别是收款账号缺失或禁用状态的情况
6. **文档更新**：更新相关技术文档和使用文档，明确 `single_royalty` 表的作用和使用规则


